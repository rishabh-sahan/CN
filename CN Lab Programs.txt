1) Hamming Code

#include <stdio.h>
void main() {
    int data[10];
    int dataatrec[10], c, c1, c2, c3, i;
    printf("Enter 4 bits of data one by one\n");
    scanf("%d", &data[0]);
    scanf("%d", &data[1]);
    scanf("%d", &data[2]);
    scanf("%d", &data[4]);
    data[6] = data[0] ^ data[2] ^ data[4];
    data[5] = data[0] ^ data[1] ^ data[4];
    data[3] = data[0] ^ data[1] ^ data[2];
    printf("\nEncoded data is\n");
    for (i = 0; i < 7; i++)
        printf("%d", data[i]);
    printf("\n\nEnter received data bits one by one\n");
    for (i = 0; i < 7; i++)
        scanf("%d", &dataatrec[i]);
    c1 = dataatrec[6] ^ dataatrec[4] ^ dataatrec[2] ^ dataatrec[0];
    c2 = dataatrec[5] ^ dataatrec[4] ^ dataatrec[1] ^ dataatrec[0];
    c3 = dataatrec[3] ^ dataatrec[2] ^ dataatrec[1] ^ dataatrec[0];
    c = c3 * 4 + c2 * 2 + c1;
    if (c == 0) {
        printf("\nNo error while transmission of data\n");
    } else {
        printf("\nError on position %d", c);
        printf("\nData sent : ");
        for (i = 0; i < 7; i++)
            printf("%d", data[i]);
        printf("\nData received : ");
        for (i = 0; i < 7; i++)
            printf("%d", dataatrec[i]);
        printf("\nCorrect message is\n");
        if (dataatrec[7 - c] == 0)
            dataatrec[7 - c] = 1;
        else
            dataatrec[7 - c] = 0;
        for (i = 0; i < 7; i++) {
            printf("%d", dataatrec[i]);
        }
    }
}

2) Stop & Wait Protocol

#include <iostream>
#include <unistd.h>
using namespace std;
int main() {
    int frames[] = {1, 2, 3, 4};
    int delaysPerFrame[] = {1, 2, 2, 1};
    cout << "Sender has to send frames: ";
    for (int i = 0; i < 4; i++)
        cout << frames[i] << " ";
    cout << endl << endl;
    cout << "Sender\t\tReceiver" << endl;
    const useconds_t shortDelay = 350000;
    for (int i = 0; i < 4; i++) {
        int frame = frames[i];
        int delayCount = delaysPerFrame[i];
        cout << "Sending Frame : " << frame << "\t";
        usleep(shortDelay);
        cout << "Received Frame : " << frame << endl;
        for (int d = 0; d < delayCount; d++) {
            usleep(shortDelay);
            cout << "\t\tDelayed Ack" << endl;
            usleep(shortDelay);
            cout << "Sending Frame : " << frame << "\t";
        }
        usleep(shortDelay);
        cout << "Received Frame : " << frame << " Duplicate" << endl;
        usleep(shortDelay);
        cout << "\t\tAcknowledgement : " << frame << endl;
    }
    return 0;
}

3) CSMA/CD

#include <iostream> 
#include <cstdlib>   
#include <ctime>   
class Station { 
public: 
    Station(std::string name) : name(name) {} 
    void send() { 
        if (carrierBusy()) { 
            std::cout << name << " detects carrier busy, deferring transmission." << std::endl; 
            return; 
        }
        std::cout << name << " is sending a message." << std::endl; 
        if (collisionDetected()) { 
            std::cout << name << " detects a collision, stopping transmission." << std::endl; 
        } else { 
            std::cout << name << " successfully transmitted the message." << std::endl; 
        } 
    } 
    bool carrierBusy() { 
         return rand() % 2 == 1; 
    } 
    bool collisionDetected() { 
        return rand() % 2 == 1; 
    } 
private: 
    std::string name; 
}; 
int main() { 
    Station stationA("Station A"); 
    Station stationB("Station B"); 
    int i=1; 
    while(i<=10){ 
        std::cout<<"Scenario"<<i<<std::endl; 
        stationA.send(); 
        stationB.send(); 
        i++; 
    } 
    return 0; 
}

4) Distance Vector Routing Algorithm

#include<stdio.h> 
#include<iostream> 
using namespace std;                                             
struct node  { 
    unsigned dist[6]; 
    unsigned from[6]; 
}DVR[10]; 
int main() { 
    cout<<"\n\n-------------------- Distance Vector Routing Algorithm----------- "; 
    int costmat[6][6]; 
    int nodes, i, j, k; 
    cout<<"\n\n Enter the number of nodes : "; 
    cin>>nodes;  
    cout<<"\n Enter the cost matrix : \n" ; 
    for(i = 0; i < nodes; i++) { 
        for(j = 0; j < nodes; j++) { 
            cin>>costmat[i][j]; 
            costmat[i][i] = 0; 
            DVR[i].dist[j] = costmat[i][j]; 
            DVR[i].from[j] = j; 
        } 
    } 
    for(i = 0; i < nodes; i++) 
        for(j = i+1; j < nodes; j++) 
            for(k = 0; k < nodes; k++) 
                if(DVR[i].dist[j] > costmat[i][k] + DVR[k].dist[j]) { 
                    DVR[i].dist[j] = DVR[i].dist[k] + DVR[k].dist[j]; 
                    DVR[j].dist[i] = DVR[i].dist[j]; 
                    DVR[i].from[j] = k; 
                    DVR[j].from[i] = k; 
                } 
        for(i = 0; i < nodes; i++) { 
            cout<<"\n\n For router: "<<i+1; 
            for(j = 0; j < nodes; j++) 
                cout<<"\t\n node "<<j+1<<" via "<<DVR[i].from[j]+1<<" Distance "<<DVR[i].dist[j]; 
        } 
    cout<<" \n\n "; 
    return 0; 
}

5) Least Cost Tree using Link State Routing Algorithm

#include <iostream> 
#include <vector> 
#include <climits> 
using namespace std; 
const int INF = INT_MAX; 
class Network { 
public: 
    int numNodes; 
    vector<vector<int>> costMatrix; 
    Network(int nodes) : numNodes(nodes) { 
        costMatrix.resize(nodes, vector<int>(nodes, INF)); 
    }
    void addLink(int node1, int node2, int cost) { 
        costMatrix[node1][node2] = cost; 
        costMatrix[node2][node1] = cost; 
    } 
    void printLeastCostTree(int source, const vector<int>& parent) { 
        cout << "Least Cost Tree:" << endl; 
        for (int i = 0; i < numNodes; ++i) { 
            if (i != source) { 
                cout << "Node " << i << " -> Node " << parent[i] << " (Cost: " << costMatrix[i][parent[i]] << ")" << endl; 
            } 
        } 
    } 
    void linkStateRouting(int source) { 
        vector<int> distance(numNodes, INF); 
        vector<bool> inTree(numNodes, false); 
        vector<int> parent(numNodes, -1); 
        distance[source] = 0; 
        for (int i = 0; i < numNodes - 1; ++i) { 
            int u = getMinDistanceVertex(distance, inTree); 
            inTree[u] = true; 
            for (int v = 0; v < numNodes; ++v) { 
                if (!inTree[v] && costMatrix[u][v] != INF && distance[u] + costMatrix[u][v] < distance[v]) { 
                    parent[v] = u; 
                    distance[v] = distance[u] + costMatrix[u][v]; 
                } 
            } 
        } 
        printLeastCostTree(source, parent); 
    } 
    int getMinDistanceVertex(const vector<int>& distance, const vector<bool>& inTree) { 
        int minDistance = INF; 
        int minVertex = -1; 
        for (int v = 0; v < numNodes; ++v) { 
            if (!inTree[v] && distance[v] < minDistance) { 
                minDistance = distance[v]; 
                minVertex = v; 
            } 
        } 
        return minVertex; 
    } 
}; 
int main() { 
    int numNodes = 4; 
    Network network(numNodes);
    network.addLink(0, 1, 4); 
    network.addLink(0, 2, 2); 
    network.addLink(1, 2, 5); 
    network.addLink(1, 3, 10); 
    network.addLink(2, 3, 1); 
    int sourceNode = 0; 
    network.linkStateRouting(sourceNode); 
    return 0; 
}

6) Client-Server Application for chat using TCP

// TCP server side 
//Include headers 
#include<stdio.h> 
#include<netinet/in.h> 
#include<netdb.h> 
#include<arpa/inet.h> 
#include<unistd.h> 
//Define server port  
#define SERV_TCP_PORT 5035 
int main(int argc,char**argv) { 
  //variable declaration 
       int sockfd,newsockfd; 
       socklen_t clength; 
       struct sockaddr_in serv_addr,cli_addr; 
       char buffer[4096]; 
   // create socket  
       sockfd=socket(AF_INET,SOCK_STREAM,0); 
   //Initialize server addres structure 
       serv_addr.sin_family=AF_INET; 
       serv_addr.sin_addr.s_addr=INADDR_ANY; 
       serv_addr.sin_port=htons(SERV_TCP_PORT); 
       printf("\nStart"); 
 // bind socket  
       bind(sockfd,(struct sockaddr*)&serv_addr,sizeof(serv_addr)); 
       printf("\nListening..."); 
       printf("\n"); 
//Listen incoming connection  
       listen(sockfd,5); 
// accept connection from client  
       clength=sizeof(cli_addr); 
       newsockfd=accept(sockfd,(struct sockaddr*)&cli_addr,&clength); 
       printf("\nConnection Accepted"); 
       printf("\n"); 
//Read client message  
       read(newsockfd,buffer,4096); 
       printf("\nClient message:%s",buffer); 
//echo back to client 
       write(newsockfd,buffer,4096); 
       printf("\n"); 
//close sockets  
       close(sockfd); 
       close(newsockfd); 
       return 0; 
} 
 
//TCP client side 
#include<stdio.h> 
#include<sys/types.h> 
#include<sys/socket.h> 
#include<netinet/in.h> 
#include<netdb.h> 
#include<unistd.h> 
#include<arpa/inet.h> 
#define SERV_TCP_PORT 5035 
int main(int argc,char*argv[])  { 
       int sockfd; 
       struct sockaddr_in serv_addr; 
       struct hostent *server; 
       char buffer[4096]; 
       sockfd=socket(AF_INET,SOCK_STREAM,0); 
       serv_addr.sin_family=AF_INET; 
       serv_addr.sin_addr.s_addr=inet_addr("127.0.0.1"); 
       serv_addr.sin_port=htons(SERV_TCP_PORT); 
        printf("\nReady for sending..."); 
       connect(sockfd,(struct sockaddr*)&serv_addr,sizeof(serv_addr)); 
       printf("\nEnter the message to send\n"); 
       printf("\nClient: "); 
       fgets(buffer,4096,stdin); 
       write(sockfd,buffer,4096); 
       printf("Serverecho:%s",buffer); 
       printf("\n"); 
       close(sockfd); 
       return 0; 
}